/**
 * contractTrigger.ts
 * 
 * Simulates smart contract interaction for TrustInfra.
 * In production: replace ethers.Contract calls with real deployed contract.
 * Architecture is designed to be a drop-in replacement.
 */

import { ethers } from 'ethers';
import { SlashEvent, ContractorNode } from './InfrastructureSimulator';

// â”€â”€â”€ ABI (matches TrustInfra.sol interface) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const TRUST_INFRA_ABI = [
    'event RiskAlert(string indexed nodeId, uint256 healthScore, uint256 slashAmount)',
    'event Recovered(string indexed nodeId, uint256 healthScore)',
    'event StakeSlashed(string indexed nodeId, uint256 amount, address indexed relayer)',
    'function slash(string nodeId, uint256 amount) external',
    'function reportRecovery(string nodeId) external',
    'function getStake(string nodeId) external view returns (uint256)',
];

// â”€â”€â”€ Config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
const RPC_URL = process.env.RPC_URL || 'http://localhost:8545';
const CONTRACT_ADDR = process.env.CONTRACT_ADDRESS || '';
const RELAYER_KEY = process.env.RELAYER_PRIVATE_KEY || '';

// â”€â”€â”€ Simulated pending queue (gas optimization: batch writes) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
interface PendingTx {
    type: 'SLASH' | 'RECOVERY';
    nodeId: string;
    payload: any;
    timestamp: number;
}

export class ContractTrigger {
    private provider: ethers.JsonRpcProvider | null = null;
    private signer: ethers.Wallet | null = null;
    private contract: ethers.Contract | null = null;
    private isLive = false;

    // Batch queue â€” only write to chain when threshold crossed
    private pendingQueue: PendingTx[] = [];
    private batchTimer: NodeJS.Timeout | null = null;
    private readonly BATCH_INTERVAL_MS = 10_000; // flush every 10s

    constructor() {
        this.init();
    }

    private init() {
        if (!CONTRACT_ADDR || !RELAYER_KEY) {
            console.log('[ContractTrigger] âš  No contract address/key â€” running in SIMULATION mode');
            this.isLive = false;
            return;
        }

        try {
            this.provider = new ethers.JsonRpcProvider(RPC_URL);
            this.signer = new ethers.Wallet(RELAYER_KEY, this.provider);
            this.contract = new ethers.Contract(CONTRACT_ADDR, TRUST_INFRA_ABI, this.signer);
            this.isLive = true;
            console.log(`[ContractTrigger] âœ… Connected to contract at ${CONTRACT_ADDR}`);

            // Start batch flush timer
            this.batchTimer = setInterval(() => this.flushBatch(), this.BATCH_INTERVAL_MS);
        } catch (err) {
            console.error('[ContractTrigger] Failed to connect:', err);
            this.isLive = false;
        }
    }

    // â”€â”€ Public API â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    /**
     * Called when a node crosses into HIGH risk.
     * Gas optimization: only triggers contract if health < threshold.
     */
    async onRiskAlert(node: ContractorNode, slash: SlashEvent): Promise<string> {
        console.log(`[ContractTrigger] ðŸ”´ RiskAlert triggered for ${node.name}`);

        if (!this.isLive) {
            // Simulation: queue and return fake tx
            this.pendingQueue.push({
                type: 'SLASH', nodeId: node.id,
                payload: { amount: slash.slashAmount, health: node.healthScore },
                timestamp: Date.now(),
            });
            return slash.txHash; // already generated by simulator
        }

        try {
            const amountWei = ethers.parseUnits(slash.slashAmount.toString(), 6); // USDC-like
            const tx = await this.contract!.slash(node.id, amountWei);
            const receipt = await tx.wait();
            console.log(`[ContractTrigger] âœ… Slash confirmed: ${receipt.hash}`);
            return receipt.hash;
        } catch (err) {
            console.error('[ContractTrigger] Slash tx failed:', err);
            return slash.txHash; // fallback to simulated hash
        }
    }

    /**
     * Called when a node recovers from HIGH risk.
     */
    async onRecovery(node: ContractorNode): Promise<string> {
        console.log(`[ContractTrigger] ðŸŸ¢ Recovery triggered for ${node.name}`);

        if (!this.isLive) {
            this.pendingQueue.push({
                type: 'RECOVERY', nodeId: node.id,
                payload: { health: node.healthScore },
                timestamp: Date.now(),
            });
            return '0x' + Math.random().toString(16).slice(2).padEnd(64, '0');
        }

        try {
            const tx = await this.contract!.reportRecovery(node.id);
            const receipt = await tx.wait();
            return receipt.hash;
        } catch (err) {
            console.error('[ContractTrigger] Recovery tx failed:', err);
            return '';
        }
    }

    /**
     * Gas optimization: flush batched non-critical updates to chain.
     */
    private async flushBatch() {
        if (this.pendingQueue.length === 0) return;
        const batch = [...this.pendingQueue];
        this.pendingQueue = [];
        console.log(`[ContractTrigger] ðŸ“¦ Flushing ${batch.length} batched tx(s) to chain`);
        // In production: use multicall or a batch contract method
        // For now: log the batch
        batch.forEach(tx => {
            console.log(`  â†’ [${tx.type}] node=${tx.nodeId} payload=${JSON.stringify(tx.payload)}`);
        });
    }

    public getPendingCount(): number { return this.pendingQueue.length; }
    public isConnected(): boolean { return this.isLive; }

    public destroy() {
        if (this.batchTimer) clearInterval(this.batchTimer);
    }
}

// Singleton
export const contractTrigger = new ContractTrigger();
